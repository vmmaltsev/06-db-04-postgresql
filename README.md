# Домашнее задание к занятию 4. «PostgreSQL» - `Мальцев Виктор`

---

Задача 1

Используя Docker, поднимите инстанс PostgreSQL (версию 13). Данные БД сохраните в volume.

Подключитесь к БД PostgreSQL, используя psql.

Воспользуйтесь командой \? для вывода подсказки по имеющимся в psql управляющим командам.

Найдите и приведите управляющие команды для:

    вывода списка БД,
    подключения к БД,
    вывода списка таблиц,
    вывода описания содержимого таблиц,
    выхода из psql.

Ответ:

1. Вывод списка БД: \l или \list
2. Подключение к БД: \c [database_name] или \connect [database_name]
3. Вывод списка таблиц: \dt
4. Вывод описания содержимого таблиц: \d [table_name]
5. Выход из psql: \q или CTRL+D

---

Задача 2

Используя psql, создайте БД test_database.

Изучите бэкап БД.

Восстановите бэкап БД в test_database.

Перейдите в управляющую консоль psql внутри контейнера.

Подключитесь к восстановленной БД и проведите операцию ANALYZE для сбора статистики по таблице.

Используя таблицу pg_stats, найдите столбец таблицы orders с наибольшим средним значением размера элементов в байтах.

Приведите в ответе команду, которую вы использовали для вычисления, и полученный результат.

Ответ:

SELECT attname, avg_width FROM pg_stats WHERE tablename='orders' ORDER BY avg_width DESC LIMIT 1;

![alt text](https://github.com/vmmaltsev/screenshot3/blob/main/Screenshot_51.png)

---

Задача 3

рхитектор и администратор БД выяснили, что ваша таблица orders разрослась до невиданных размеров и поиск по ней занимает долгое время. Вам как успешному выпускнику курсов DevOps в Нетологии предложили провести разбиение таблицы на 2: шардировать на orders_1 - price>499 и orders_2 - price<=499.

Предложите SQL-транзакцию для проведения этой операции.

Можно ли было изначально исключить ручное разбиение при проектировании таблицы orders?

Ответ:

Для разбиения таблицы orders на две таблицы orders_1 и orders_2 в соответствии с условием (price>499 и price<=499 соответственно), можно использовать следующую SQL-транзакцию:

BEGIN;

CREATE TABLE orders_1 AS SELECT * FROM orders WHERE price > 499;
CREATE TABLE orders_2 AS SELECT * FROM orders WHERE price <= 499;

DROP TABLE orders;

COMMIT;

В этой транзакции сначала создаются две новые таблицы orders_1 и orders_2 путем выбора записей из исходной таблицы orders в соответствии с условием цены. Затем исходная таблица orders удаляется. Все эти операции выполняются в рамках одной транзакции, чтобы обеспечить консистентность данных.

Стоит заметить, что этот подход приведет к потере всех связанных с таблицей orders объектов, таких как индексы, ограничения и триггеры. Будет нужно вручную воссоздать их для новых таблиц orders_1 и orders_2 при необходимости.

Что касается второго вопроса, то ответ - да, можно было изначально исключить ручное разбиение при проектировании таблицы orders. PostgreSQL поддерживает механизм, называемый "table partitioning" (разбиение таблицы), который позволяет автоматически разбивать таблицу на меньшие части или "партиции" на основе определенных критериев, таких как диапазон значений столбца. Это может значительно улучшить производительность для больших таблиц.

В случае с таблицей orders, можно было с самого начала настроить разбиение на партиции по столбцу price, чтобы автоматически разделить данные на две партиции в зависимости от значения цены. Это выглядит примерно так:

CREATE TABLE orders (
    id integer NOT NULL,
    title character varying(80) NOT NULL,
    price integer DEFAULT 0
) PARTITION BY RANGE (price);

CREATE TABLE orders_1 PARTITION OF orders FOR VALUES FROM (500) TO (MAXVALUE);
CREATE TABLE orders_2 PARTITION OF orders FOR VALUES FROM (MINVALUE) TO (500);

В этом примере создается родительская таблица orders, которая разбивается на партиции по диапазону значений столбца price. Затем создаются две партиционные таблицы orders_1 и orders_2, которые хранят записи с price > 499 и price <= 499 соответственно.

---

Задача 4

Используя утилиту pg_dump, создайте бекап БД test_database.

Как бы вы доработали бэкап-файл, чтобы добавить уникальность значения столбца title для таблиц test_database?


Ответ:

Для добавления уникальности значения столбца title для таблиц в test_database необходимо добавить ограничение уникальности (UNIQUE constraint) для этого столбца. Это можно сделать отредактировав файл бэкапа.

Нужно открыть файл бэкапа в текстовом редакторе и найти строку, которая создает таблицу, для которой нужно добавить ограничение. Это будет выглядеть примерно так:

CREATE TABLE public.orders (
  id integer NOT NULL,
  title character varying(80) NOT NULL,
  price integer DEFAULT 0
);

Нужно добавить UNIQUE после определения столбца title, чтобы сделать его уникальным:

CREATE TABLE public.orders (
  id integer NOT NULL,
  title character varying(80) NOT NULL UNIQUE,
  price integer DEFAULT 0
);

Теперь при восстановлении базы данных из этого файла бэкапа, столбец title будет иметь ограничение уникальности.

При этом если в базе данных уже есть дубликаты значений в столбце title, восстановление бэкапа с этим изменением приведет к ошибке. В этом случае нужно будет сначала удалить или изменить дубликаты в исходной базе данных, или в файле бэкапа перед восстановлением.


